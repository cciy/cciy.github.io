[{"content":"新建spring项目 Idea 按如下操作：File -\u0026gt; New -\u0026gt; Project 1、修改pom.xml文件依赖包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-geek-demo\u0026lt;/artifactId\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;spring-ioc\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;spring.version\u0026gt;5.2.2.RELEASE\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 2、删除src文件夹，新建Module -\u0026gt; spring-ioc修改spring-ioc\n","date":"2022-07-02T00:00:00Z","permalink":"https://cciy.github.io/springioc/","title":"SpringIoc"},{"content":"1、注解类ResponeResult 如下代码实现注解ResponeResul\n1 2 3 4 5 6 7 8 9 10 package com.example.springcs.annotation; import java.lang.annotation.*; @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE,ElementType.METHOD}) @Documented public @interface ResponeResult { } 2、返回枚举的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package com.example.springcs.utils; public enum EnumCode { SUCCESS(20000, \u0026#34;success\u0026#34;), REDIRECT(10000, \u0026#34;success\u0026#34;), NOAD(20001, \u0026#34;no ad exists\u0026#34;), ERR_HTTP(40000, \u0026#34;http content-type error\u0026#34;), ERR_APP_NULL(40001, \u0026#34;app info is required\u0026#34;), ERR_APP_INFO(40002, \u0026#34;invalid app info\u0026#34;), ERR_ADCODE_NULL(40003, \u0026#34;ad code is required\u0026#34;), ERR_ADTYPE_NULL(40004, \u0026#34;ad type is required\u0026#34;), ERR_SCHE_NULL(40005, \u0026#34;scheduler not exist\u0026#34;), ERR_UAD_REPEAT(40006, \u0026#34;user ad repeated\u0026#34;), ERR_PLATFORM_NULL(40007, \u0026#34;platform config not exist\u0026#34;), ERR_REQ_CONTENT_DEFECT(40009, \u0026#34;request content data defect\u0026#34;), ERR_UNKNOWN_TOKEN(40010, \u0026#34;unknown token\u0026#34;), ERR_SIGNATURE(40011, \u0026#34;signature error\u0026#34;), ERR_BLACKLIST(40012, \u0026#34;user blocked by blacklist\u0026#34;), ERR_SERVER(50001, \u0026#34;server error\u0026#34;), ERR_DATA(50002, \u0026#34;data error\u0026#34;), ERR_TIMEOUT(50003, \u0026#34;request ad server timeout\u0026#34;), ERR_ANTI_CHEAT(50004, \u0026#34;user blocked by anti cheat\u0026#34;), ERR_UNKNOWN(50005, \u0026#34;unknown error\u0026#34;), ERR_MATERIAL_RULES(50006, \u0026#34;ad material blocked\u0026#34;), ERR_MATERIAL_UNAPPROVED(50007, \u0026#34;ad material is unapproved\u0026#34;), ERR_MATERIAL_FILTERED(50008, \u0026#34;ad material are filtered\u0026#34;), ERR_MATERIAL_AUDITED(50009, \u0026#34;ad material are audited\u0026#34;), ERROR_PARAM(60001, \u0026#34;param error\u0026#34;), ERROR_ACCESS(60002, \u0026#34;access error\u0026#34;); private Integer code; private String msg; private EnumCode(Integer code, String msg) { this.code = code; this.msg = msg; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } 3、返回类Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.example.springcs.utils; import lombok.Data; import java.io.Serializable; @Data public class Result implements Serializable { private Integer code; private String msg; private Object data; public Result(EnumCode enumErrorCode, Object data) { this.code = enumErrorCode.getCode(); this.msg = enumErrorCode.getMsg(); this.data = data; } public static Result success(Object data) { return new Result(EnumCode.SUCCESS, data); } public static Result failure(EnumCode enumErrorCode, Object data) { return new Result(enumErrorCode, data); } } 4、新建Spring拦截器 4.1、通过实现HandlerInterceptor接口将请求的url代码入下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.example.springcs.interceptor; import com.example.springcs.annotation.ResponeResult; import org.springframework.context.annotation.Configuration; import org.springframework.stereotype.Component; import org.springframework.web.method.HandlerMethod; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.lang.reflect.Method; @Component public class ResponseResultInterceptor implements HandlerInterceptor { public static final String RESPONSE_RESULT_ANN = \u0026#34;RESPONSE-RESULT-ANN\u0026#34;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //请求方法 if (handler instanceof HandlerMethod) { final HandlerMethod handlerMethod = (HandlerMethod) handler; final Class\u0026lt;?\u0026gt; clazz = handlerMethod.getBeanType(); final Method method = handlerMethod.getMethod(); //判断是否在类对象上加上注解 if (clazz.isAnnotationPresent(ResponeResult.class)) { request.setAttribute(RESPONSE_RESULT_ANN, clazz.getAnnotation(ResponeResult.class)); } else if(method.isAnnotationPresent(ResponeResult.class)) { request.setAttribute(RESPONSE_RESULT_ANN, method.getAnnotation(ResponeResult.class)); } } return true; } } 4.2、通过实现WebMvcConfigurer方法将所自己实现的ResponseResultInterceptor加入到Spring的拦截器中代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package com.example.springcs.interceptor; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import javax.annotation.Resource; @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Resource private ResponseResultInterceptor loginInterceptor; /** * 注册自定义拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) { InterceptorRegistration interceptorRegistration = registry.addInterceptor(loginInterceptor); //可以设置多个路径拦截，我设置的是拦截全部 interceptorRegistration.addPathPatterns(\u0026#34;/**\u0026#34;); } } 5、重写返回类 下面代码就是判断是否需要返回值包装，如果需要就直接包装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.example.springcs.handler; import com.example.springcs.annotation.ResponeResult; import com.example.springcs.utils.Result; import org.springframework.core.MethodParameter; import org.springframework.http.MediaType; import org.springframework.http.converter.HttpMessageConverter; import org.springframework.http.server.ServerHttpRequest; import org.springframework.http.server.ServerHttpResponse; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice; import javax.servlet.http.HttpServletRequest; @ControllerAdvice public class ResponseResultHandler implements ResponseBodyAdvice\u0026lt;Object\u0026gt; { public static final String RESPONSE_RESULT_ANN = \u0026#34;RESPONSE-RESULT-ANN\u0026#34;; @Override public boolean supports(MethodParameter returnType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converterType) { ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = sra.getRequest(); //判断请求是否有包装标记 ResponeResult responeResult = (ResponeResult) request.getAttribute(RESPONSE_RESULT_ANN); return responeResult != null; } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { return Result.success(body); } } 6、写测试controller 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.example.springcs.controller; import com.example.springcs.annotation.ResponeResult; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; @RestController @ResponeResult public class TestController { @RequestMapping(\u0026#34;/test\u0026#34;) @ResponseBody public int test() { return 1; } } ","date":"2021-07-22T00:00:00Z","permalink":"https://cciy.github.io/springboot%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%BB%9F%E4%B8%80%E8%BE%93%E5%87%BA/","title":"SpringBoot优雅的实现接口统一输出"},{"content":"问题 Windows 10安装MongoDB后想使用mongodump和mongorestore命令，进行数据的导入和导出，发现在安装的目录下的bin目录，发现bin目录中并没有对应的mongodump和mongorestore。\n原因 MongoDB4.4版本进行了功能拆分，如需要更多的工具，自行下载\n解决方法 在官网自行下载对应的Tools工具,然后解压放到MongoDB的安装目录下面，再配置环境就可以直接在windows下使用mongodump和mongorestore 博客参考来源:\nmongoDB4.4版本没有mongodump和mongorestore命令\n","date":"2021-07-21T00:00:00Z","permalink":"https://cciy.github.io/mongodb%E6%B2%A1%E6%9C%89mongodump%E5%92%8Cmongorestore%E5%91%BD%E4%BB%A4/","title":"MongoDB没有mongodump和mongorestore命令"},{"content":"通过Jdk的命令javap可以反编译查看字节码 按照如下图所示填写相关参数\n添加工具，分别设置program，argument等，其中arguments中是javap的参数，具体的参数信息可以去看下help信息 博客参考来源:\nIDEA设置External Tools之Javap反编译字节码\nintellij idea中使用External Tool实现javap工具反编译\n","date":"2021-05-17T00:00:00Z","permalink":"https://cciy.github.io/idea%E5%AE%9E%E7%8E%B0javap%E5%B7%A5%E5%85%B7%E5%8F%8D%E7%BC%96%E8%AF%91/","title":"Idea实现javap工具反编译"},{"content":"最新版的idea启动和老版启动不太一样\n然后点击下图按钮\n添加即可多次启动同一个 main 方法\n","date":"2021-05-08T00:00:00Z","permalink":"https://cciy.github.io/idea%E5%A4%9A%E6%AC%A1%E5%90%AF%E5%8A%A8/","title":"idea多次启动"},{"content":"hugo官网Markdown和其他与标记相关的配置 根据hugo官网中Markdown设置代码块高亮的配置\n如图： 将其配置拷贝到你的hugo配置中\n1 2 3 4 5 6 7 8 9 10 11 12 13 markup: highlight: anchorLineNos: false codeFences: true guessSyntax: false hl_Lines: \u0026#34;\u0026#34; lineAnchors: \u0026#34;\u0026#34; lineNoStart: 1 #行从几开始 lineNos: false #是否显示行列 lineNumbersInTable: true noClasses: true style: monokai #代码样式 tabWidth: 4 其中代码的样式可以通过style样式指定\n如想单独配置某一个代码块，可以按照官网例子如下配置：\n添加Cope按钮 1、定义按钮样式，将cope的css加入到custom.scss文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .highlight-copy-btn { position: absolute; top: 7px; right: 7px; border: 0; border-radius: 4px; padding: 1px; font-size: 0.8em; line-height: 1.8; color: #fff; background-color: #777; min-width: 55px; text-align: center; } .highlight-copy-btn:hover { background-color: #666; } 2、将按钮点击后触发的js加入到加入到js文件中： 我这边是将js加入到main.ts文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //拷贝代码按钮 var highlightBlocks = document.getElementsByClassName(\u0026#39;highlight\u0026#39;); if (highlightBlocks != null) { console.info(highlightBlocks); Array.prototype.forEach.call(highlightBlocks, addCopyButton); } function selectText(node) { var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(node); selection.removeAllRanges(); selection.addRange(range); return selection; } function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function () { el.textContent = \u0026#34;Copy\u0026#34;; }, 1000); } function addCopyButton(containerEl) { var copyBtn = document.createElement(\u0026#34;button\u0026#34;); copyBtn.className = \u0026#34;highlight-copy-btn\u0026#34;; copyBtn.textContent = \u0026#34;Copy\u0026#34;; var codeEl = containerEl.firstElementChild.firstElementChild.firstElementChild.firstElementChild.children[1]; copyBtn.addEventListener(\u0026#39;click\u0026#39;, function () { try { var selection = selectText(codeEl); document.execCommand(\u0026#39;copy\u0026#39;); selection.removeAllRanges(); flashCopyMessage(copyBtn, \u0026#39;Copied!\u0026#39;) } catch (e) { console \u0026amp;\u0026amp; console.log(e); flashCopyMessage(copyBtn, \u0026#39;Failed :\\\u0026#39;(\u0026#39;) } }); containerEl.appendChild(copyBtn); } 博客参考来源: hugo博客自定义代码块\n","date":"2021-05-07T00:00:00Z","permalink":"https://cciy.github.io/hugo%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%9D%97/","title":"hugo修改代码块"},{"content":"IDEA原始PDF文档查看 点击Idea顶部菜单栏中 Help -\u0026gt; Keymap Reference，后出现一个快捷键PDF文档。\n一、Editing编辑 代码补全\n快捷键 说明 使用频率 Ctrl + Space 基本的代码补全（类名、方法、变量） ★★ Ctrl + Shift + Space 代码智能补全（类名、方法、变量） ☆ Ctrl + Shift + Enter 智能结束代码 ☆ 显示查看\n快捷键 说明 使用频率 Ctrl + P 显示该方法的参数信息（光标放在被调用方法的圆括号内，然后按此快捷键） ★★★★ Ctrl + Q 代码智能补全（类名、方法、变量） ★ Shift + F1 显示外部文档 ☆ Ctrl +鼠标放在代码上 显示基本信息 ☆ Ctrl + F1 在错误或警告处显示描述信息 ☆ Alt + Q 显示上下文信息 ☆ 快速生成 / 提示\n快捷键 说明 使用频率 Alt + Insert 生成代码（Getters, Setters, Constructors,hashCode/equals, toString） ★★★★ Ctrl + O 重写方法 ★ Ctrl + I 实现方法 ★ Ctrl + Alt + T 用xxx包围(if..else,try..catch, for,synchronized, 等) ★★★★ Ctrl + / 注释/取消注释，行注释 ★★★★ Ctrl + Shift + / 注释/取消注释，块注释 ★★★★ Ctrl + W 依次递增选中代码块 ★★ Ctrl + Shift + W 减少当前选中的代码块 ★★ Alt + Enter 显示意向动作和快速修复代码 ★★★ 优化（格式化，去除多余，优化import）\n快捷键 说明 使用频率 Ctrl + Alt + L 格式化代码 ★★★★ Ctrl + Alt + O 优化 import ★★★ Ctrl + Alt + I 自动缩进行 ★ Tab / Shift + Tab 缩进 / 反缩进 选中的代码 ☆ 剪切、复制、粘贴、删除\n快捷键 说明 使用频率 Ctrl+X/Shift+Delete 剪切当前行或选定的块到剪贴板 ★★★★ Ctrl+C/Ctrl+Insert 复制当前行或选定的块到剪贴板 ★★★★ Ctrl+V/Shift+Insert 从最新剪贴板粘贴 ★★★★ Ctrl+ Shift + V 选择剪切板最近100条的内容 ★ Ctrl + D 复制粘贴当前行或选定的块 ★★★ Ctrl + Y 删除当前行或选定的块 ★★★ Ctrl + Delete 删除到单词的末尾 ★ Ctrl + Backspace 删除到单词的开头 ★ 普通edit操作\n快捷键 说明 使用频率 Shift + Enter 开始新的一行 ★★★ Ctrl + Shift + U 字母大小写切换 ★ Ctrl + Shift + ] / [ 选择直到代码块结束/开始 ★★ Ctrl + Enter 将代码拆分行 ☆ Ctrl + +/- 展开/ 折叠代码块 ★ Ctrl + F4 关闭活动的编辑器(editor)选项卡 ☆ 二、Search/Replace （搜索 / 替换） 快捷键 说明 使用频率 双击Shift 查询任何东西(包括文件夹、文件以及字符串) ★★★★ Ctrl + F 在当前编辑器里面查询字符串 ★★★★ Ctrl + Shift + F 查找该项目中所有字符串 ★★★★ F3 查询下一个 ★★★★ Shift + F3 查询上一个 ★★★★ Ctrl + R 替换当前窗口的的字符串 ★★ Ctrl + Shift + R 替换当前窗口的的字符串 ★★ 三、Usage Search （使用点查询，即哪儿使用了这个类/方法/变量） 快捷键 说明 使用频率 Alt + F7 全局查找使用地点 ★★★ Ctrl + F7/Ctrl + Shift + F7 在文件中查找使用地点/在文件中高亮显示使用地点 ★★ Ctrl + Alt + F7 显示使用地点 ★★ 四、Compile and Run （编译和运行） 快捷键 说明 使用频率 Ctrl + F9 编译项目(编译修改和依赖) ★ Ctrl + Shift + F9 编译选择的文件、包或模块 ★ Alt + Shift + F10 选择配置并run ★★★ Alt + Shift + F9 选择配置并Debug ★★★ Shift + F10 run ★★★★ Shift + F9 Debug ★★★★ Ctrl + Shift + F10 从编辑器运行上下文配置 ★★★★ 五、Debugging （调试） 快捷键 说明 使用频率 F8 下一步 ★★★★ F7 进入方法内部 ★★★★ Shift + F8 跳出这个方法 ★★★ Alt + F9 运行到光标处（如果光标前有其他断点会进入到该断点） ★★★ Alt + F8 计算表达式（可以更改变量值使其生效） ★★★ F9 恢复程序运行（如果该断点下面代码还有断点则停在下一个断点上） ★★★ Ctrl + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） ★★★ Ctrl + Shift + F8 查看断点列表 ★★★ Shift + F7 智能步入（断点所在行上有多个方法调用，会弹出进入哪个方法） ★ 六、Navigation （导航） 跳转\n快捷键 说明 使用频率 Ctrl + N 搜索指定类并可以点击跳转 ★★★★ Ctrl + Shift + N 搜索指定文件并可以点击跳转 ★★★★ Ctrl + Alt + Shift + N 搜索指定文件目标（变量 / 方法）并可以点击跳转 ★★★★ Ctrl + G 跳转到指定行 ★★★★ Ctrl + U 跳转到父类/ 接口的对应处 ★★★★ Ctrl + Alt + B 跳转到当前类的类处 ★★ Ctrl + Alt + Left/Right 跳转到上一次 / 下一次操作处 ★★ Ctrl + Shift + Backspace 跳转到最后一次编辑处 ★★ Alt + Up/Down 跳转到上一个 / 下一个方法名处 ★★★★ F2 / Shift + F2 跳转到下一个 / 上一个高亮错误处 ★★ Ctrl + [ / ] 跳转到当前所在代码块花括号开始 / 结束处 ★★ 弹出\n快捷键 说明 使用频率 Ctrl + E 弹出最近打开的文件列表 ★★★★ Ctrl + F12 弹出文件结构，类似eclipse的outline ★★★★ Ctrl + H 弹出类的层次结构（即父类、子类） ★★ Ctrl + Shift + H 弹出方法层次结构 ★★ Ctrl + Alt + H 弹出调用层次（哪些类调用了此处） ★★ Ctrl + Alt + I 弹出方法 / 变量定义预览 ★★ 窗口\n快捷键 说明 使用频率 Alt + F1 选择文件变量或者视图 ★★★★ F12 返回到前一个工具窗口 ☆ Esc 跳转到代码编辑窗口（从工具窗口） ★ Shift + Esc 隐藏活动窗口或上次活动窗口 ★ Alt + Right/Left 在打开的编辑tab页（即.java文件）之间切换 ★★ Ctrl + Shift +F4 关闭活动的 run/messages/find/\u0026hellip; tab页 ☆ F4 / Ctrl + Enter 编辑 / 查看源代码 ☆ Alt + Home 显示导航条 ☆ 书签\n快捷键 说明 使用频率 F11 选中文件/文件夹/代码行，添加/取消书签 ★ Ctrl + F11 选中文件/文件夹/代码行，用助记符切换书签 ★ Ctrl + #[0-9] 跳转到对应数值的书签处 ★ Shift + F11 显示所有书签 ★ 七、Refactoring（重构）### 快捷键 说明 使用频率 F5 复制 ★ F6 移动 ★ Alt + Delete 安全删除 ★ Shift + F6 重命名 ★★★ Ctrl + F6 更改签名 ★ Ctrl + Alt + N 一致性 ★ Ctrl + Alt + M 将选中的代码抽取为方法 ★ Ctrl + Alt + V 将选中的代码抽取为变量 ★ Ctrl + Alt + F 将选中的代码抽取为字段 ★ Ctrl + Alt + C 将选中的代码抽取为常量 ★ Ctrl + Alt + P 将选中的代码抽取为参数 ★ 八、VCS/Local History（版本控制/本地历史记录）### 快捷键 说明 使用频率 Ctrl + K 提交代码到版本控制器 ★★★★★ Ctrl + T 从版本控制器更新代码 ★★★★★ Alt + Shift + C 查看最近的变更记录 ★★★★★ Alt + `(数字键1旁边的反引号) 快速弹出版本控制器操作面板 ★★★★★ 九、Live Templates（动态代码模板） 快捷键 说明 使用频率 Ctrl + Alt + J 将选定的代码使用动态模板包住 ★ Ctrl + J 插入代码模板 ★★ 十、General（通用） 快捷键 说明 使用频率 Alt + #[0-9] 打开相应编号的工具窗口 ☆ Ctrl + S 保存所有 ☆ Ctrl + Alt + Y 同步、刷新 ☆ Ctrl + Shift + F12 切换最大化编辑器 ★★★★★ Alt + Shift + F 添加到收藏夹 ☆ Alt + Shift + I 使用当前配置审查当前文件（代码审查） ☆ Ctrl + BackQuote (`，数字键1旁边的反引号) 快速切换当前的scheme（切换主题、代码样式等） ☆ Ctrl + Alt + S 打开IDEA系统设置窗口 ☆ Ctrl + Alt + Shift + S 打开项目结构对话框 ☆ Ctrl + Shift + A 查找动作 ☆ Ctrl + Tab 编辑窗口标签和工具窗口之间切换（切换器，不同的地方效果不同） ★★★★★ 博客参考来源: IDEA快捷键For Windows\n","date":"2021-04-21T00:00:00Z","permalink":"https://cciy.github.io/idea%E5%BF%AB%E6%8D%B7%E9%94%AEfor-windows/","title":"IDEA快捷键For Windows"},{"content":"选择Hugo的理由 截止2021年4月17日\n☆star数目：\nHugo ：51.3k\nJekyll：42.5k\nHexo： 32.6k\n编译速度:\nHugo\u0026gt;Hexo\u0026gt;Jekyll\n之所以有这样的结果是因为Hugo使用go语言是一种编译型语言，速度非常快，而Jekyll使用ruby编写，hexo使用nodejs编写，ruby与nodejs都是面向对象的高级解释型语言，执行效率比编译型语言要低。为什么Hexo介于二者之间，因为Nodejs的V8引擎比Ruby实现的方法要快。\n其他方面\nJekyll有github支持，可以将markdown文件直接放到git仓库，github会自动生成网页文件。（Github一直是一个亲ruby的社区）\nHexo提供了方便的部署命令，可以做到一条命令部署到github上，Hexo的主题非常多。\nHugo的官方文档写的非常好，部署简洁。前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限\nHugo下载 从Hugo Releases下载适合您平台的版本。\n由于我是windows10环境，我这边下载安装的是hugo的扩展版Hugo Extended，扩展版和普通版的区别是扩展版可以自动编译scss的样式。\nHugo安裝 将下载好的hugo_extended_0.82.0_Windows-64bit.zip安装包解压到你要安装的盘，然后配置环境变量。\n如我安装的在d盘,解压后修改文件夹名称为hugo，然后把D:\\hugo加到环境变量的PATH中，这一步很关键。\n查看是否安装成功：hugo version\n","date":"2021-04-14T00:00:00Z","permalink":"https://cciy.github.io/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"hugo博客搭建"},{"content":"什么是位运算符 位运算符对一个或者多个值进行计算，并得出一个计算结果。 位运算符的运算结果类型有的是固定的，会根据被计算的值变化。比如两个int相加，结果类型就是int。两个byte相加，返回值就是byte。 混淆点：除了赋值运算符外，运算符本身不会更改变量的值 代码示例\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { int a = 100; System.out.println(a + 1); System.out.println(a); a=a+6; System.out.println(a); } } 输出结果为：101 100 106\n取模运算符：% 用来计算余数 负数也可以取模 负数也可以被取模 小数也可以取模 代码示例\n1 2 3 4 5 6 7 8 9 10 11 public class Main { public static void main(String[] args) { int num = 10; System.out.println(num % 2); System.out.println(num % -3); System.out.println(num % 4); System.out.println(num % 5); System.out.println(num % -6); } } 输出结果为：0 1 2 0 4\n整数的除法运算 int除以int还是int，不会变成浮点数\n代码示例\n1 2 3 4 5 6 7 8 public class Main { public static void main(String[] args) { int a = 10; int b = 3; System.out.println(a / b); } } 输出结果为3，如果想要得到一个浮点数只需将b改为double b=3.0得出的结果为3.3333333333333335，因为double是有精度的。\n比较运算符和布尔运算符 比较运算符\n\u0026gt; \u0026gt;= \u0026lt; \u0026lt;= != == 布尔运算符\n!叫做非运算符。not运算符。!true是false，!false是true。 \u0026amp;叫做且运算符。and运算符。true\u0026amp;true是true，true\u0026amp;false是false。 \u0026amp;\u0026amp;叫做且且运算符。andand运算符。运算结果和\u0026amp;一样 |叫做或运算符。or运算符。true|false是true，false|false是false，true|trues是true. ","date":"2021-04-10T00:00:00Z","permalink":"https://cciy.github.io/java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"java位运算符"}]